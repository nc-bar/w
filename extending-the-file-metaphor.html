<h2>Extending the file metaphor</h2>

<p>
	Unix included security features from the time it introduced 
	fle permissions and users. Files have owners, both groups and
	users, and a set of permissions. For example:
</p>

<code><pre>
d-rwxr-xr-x M 0 ncb ncb      0 Aug  6 12:24 forth
d-rwxr-xr-x M 0 ncb ncb      0 Aug  3 23:03 groff
--rw-r--r-- M 0 ncb ncb   1596 Jul 31 18:11 installing-noweb-in-openbsd.md
d-rwxr-xr-x M 0 ncb ncb      0 Aug  5 15:47 ncb.ar
</pre></code>

<p>
	The list above is a list of files and directories
	(the latter beign just a kind of file).
	The most important part of every item,
	concerning security, are the ownership and the permissions flags:
</p>

<pre>
--rw-r--r-- ncb ncb      installing-noweb-in-openbsd.md
d-rwxr-xr-x ncb ncb      ncb.ar
</pre>

<p>
	The second and third columns say that the <code>ncb</code> user
	and the <code>ncb</code> group own the file.
</p>

<p>
	The first column is a string of flags which say who can
	<code>read</code>, <code>open</code> or <code>execute</code> the file.
	The first flag in the first row above, (<code>-</code>) indicates that
	<code>installing-noweb-in-openbsd.md</code> is a normal file;
	the second row says that <code>ncb.ar</code> is a directory (<code>d</code>).
</p>

<p>
	The last three triplets set the <code>owner</code> user, <code>group</code> owner and <code>other</code> users permissions.
	Letters <code>r</code>, <code>w</code> and <code>x</code> denote <code>read</code>, <code>write</code> and <code>execute</code>:
</p>

<pre>
	--rw-r--r-- ncb ncb      installing-noweb-in-openbsd.md
	d-rwxr-xr-x ncb ncb      ncb.ar
</pre>

<p>
	In this case, the user <code>ncb</code> can <code>r</code>ead and <code>w</code>rite
	the <code>installing-noweb-in-openbsd.md</code> file but it can't e<code>x</code>ecute it.
	The <code>d</code> in the beginning of the second row implies the file is a directory;
	the execution permission in a directory means it can be opened.
</p>

<p>
	This scheme is very flexible and can be used to secure the access to files.
	If that is the case, why not extend it to everything? I mean:
	want to launch a process? you need permissions to open and write into <code>/proc</code>,
	after all, creating a process from an executable file could be done by:
</p>

<pre>
	cp a.out /proc/user/
</pre>

<p>
	Want to open a socket?
</p>

<pre>
	fp = fopen("/sockets/some-name", RW);
</pre>

<p>
	By extending the file methaphor, all the different interfaces and 
	permissions merge into the file system. The programmer doesn't need
	to learn other system calls and their permissions and restrictions.
	Libraries would also be simplified, after all many syscalls would just
	be familiar operations on files.
</p>

<p>
	Another interesting application would be to restrict a process capabilities
	by restricting it's view of the file system.
	For example, if some server should never send or receive packets from an interface,
	just unmount that part of the file system.
	Something similar to openBSD's <a href="https://man.openbsd.org/unveil.2">unveil</a>.
	A process could unmount some filesystem and then <code>exec</code> into another process 
	which can't re-mount it.
</p>
